{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/nodes/node.mjs","webpack:///./src/nodes/container.mjs","webpack:///./src/parse-media/feature.mjs","webpack:///./src/parse-media/query.mjs","webpack:///./src/parse-media/list.mjs","webpack:///./src/parse-media/index.mjs","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","w","s","Node","opts","this","after","before","type","sourceIndex","container","[object Object]","super","nodes","undefined","length","forEach","node","parent","filter","cb","hasFilter","RegExp","callback","filterReg","test","walk","feature","string","index","modesEntered","mode","character","result","lastModeIndex","mediaFeature","colon","mediaFeatureValue","indexLocal","stringNormalized","substring","isCalculationEnabled","push","pop","mediaFeatureValueStr","exec","trim","query","localLevel","insideSomeValue","search","indexOf","Array","isArray","list","interimIndex","levelLocal","doesHaveUrl","parenthesesLv","unshift","mediaQueryString","spaceBefore","__webpack_exports__","_parseMedia"],"mappings":"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","file":"index.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading wasm modules\n \tvar installedWasmModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// object with all compiled WebAssembly.Modules\n \t__webpack_require__.w = {};\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/**\n * A very generic node. Pretty much any element of a media query\n */\n\nexport default function Node(opts) {\n  this.after = opts.after\n  this.before = opts.before\n  this.type = opts.type\n  this.value = opts.value\n  this.sourceIndex = opts.sourceIndex\n}\n","//---------//\n// Imports //\n//---------//\n\nimport Node from './node'\n\n//\n//------//\n// Main //\n//------//\n\n/**\n * A node that contains other nodes and support traversing over them\n */\nclass Container extends Node {\n  constructor(opts) {\n    super(opts)\n\n    this.nodes = opts.nodes\n\n    if (this.after === undefined) {\n      this.after =\n        this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ''\n    }\n\n    if (this.before === undefined) {\n      this.before = this.nodes.length > 0 ? this.nodes[0].before : ''\n    }\n\n    if (this.sourceIndex === undefined) {\n      this.sourceIndex = this.before.length\n    }\n\n    this.nodes.forEach(node => {\n      node.parent = this // eslint-disable-line no-param-reassign\n    })\n  }\n\n  /**\n   * Iterate over descendant nodes of the node\n   *\n   * @param {RegExp|string} filter - Optional. Only nodes with node.type that\n   *    satisfies the filter will be traversed over\n   * @param {function} cb - callback to call on each node. Takes theese params:\n   *    node - the node being processed, i - it's index, nodes - the array\n   *    of all nodes\n   *    If false is returned, the iteration breaks\n   *\n   * @return (boolean) false, if the iteration was broken\n   */\n  walk(filter, cb) {\n    const hasFilter = typeof filter === 'string' || filter instanceof RegExp\n    const callback = hasFilter ? cb : filter\n    const filterReg = typeof filter === 'string' ? new RegExp(filter) : filter\n\n    for (let i = 0; i < this.nodes.length; i++) {\n      const node = this.nodes[i]\n      const filtered = hasFilter ? filterReg.test(node.type) : true\n      if (filtered && callback && callback(node, i, this.nodes) === false) {\n        return false\n      }\n      if (node.nodes && node.walk(filter, cb) === false) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * Iterate over immediate children of the node\n   *\n   * @param {function} cb - callback to call on each node. Takes theese params:\n   *    node - the node being processed, i - it's index, nodes - the array\n   *    of all nodes\n   *    If false is returned, the iteration breaks\n   *\n   * @return (boolean) false, if the iteration was broken\n   */\n  each(cb = noop) {\n    for (let i = 0; i < this.nodes.length; i++) {\n      const node = this.nodes[i]\n      if (cb(node, i, this.nodes) === false) {\n        return false\n      }\n    }\n    return true\n  }\n}\n\n//\n//------------------//\n// Helper Functions //\n//------------------//\n\nfunction noop() {}\n\n//\n//---------//\n// Exports //\n//---------//\n\nexport default Container\n","//------//\n// Main //\n//------//\n\n/**\n * Parses a media feature expression, e.g. `max-width: 10px`, `(color)`\n *\n * @param {string} string - the source expression string, can be inside parens\n * @param {Number} index - the index of `string` in the overall input\n *\n * @return {Array} an array of Nodes, the first element being a media feature,\n *    the secont - its value (may be missing)\n */\n\nfunction parseMediaFeature(string, index = 0) {\n  const modesEntered = [\n    {\n      mode: 'normal',\n      character: null,\n    },\n  ]\n  const result = []\n  let lastModeIndex = 0\n  let mediaFeature = ''\n  let colon = null\n  let mediaFeatureValue = null\n  let indexLocal = index\n\n  let stringNormalized = string\n  // Strip trailing parens (if any), and correct the starting index\n  if (string[0] === '(' && string[string.length - 1] === ')') {\n    stringNormalized = string.substring(1, string.length - 1)\n    indexLocal++\n  }\n\n  for (let i = 0; i < stringNormalized.length; i++) {\n    const character = stringNormalized[i]\n\n    // If entering/exiting a string\n    if (character === \"'\" || character === '\"') {\n      if (modesEntered[lastModeIndex].isCalculationEnabled === true) {\n        modesEntered.push({\n          mode: 'string',\n          isCalculationEnabled: false,\n          character,\n        })\n        lastModeIndex++\n      } else if (\n        modesEntered[lastModeIndex].mode === 'string' &&\n        modesEntered[lastModeIndex].character === character &&\n        stringNormalized[i - 1] !== '\\\\'\n      ) {\n        modesEntered.pop()\n        lastModeIndex--\n      }\n    }\n\n    // If entering/exiting interpolation\n    if (character === '{') {\n      modesEntered.push({\n        mode: 'interpolation',\n        isCalculationEnabled: true,\n      })\n      lastModeIndex++\n    } else if (character === '}') {\n      modesEntered.pop()\n      lastModeIndex--\n    }\n\n    // If a : is met outside of a string, function call or interpolation, than\n    // this : separates a media feature and a value\n    if (modesEntered[lastModeIndex].mode === 'normal' && character === ':') {\n      const mediaFeatureValueStr = stringNormalized.substring(i + 1)\n      mediaFeatureValue = {\n        type: 'value',\n        before: /^(\\s*)/.exec(mediaFeatureValueStr)[1],\n        after: /(\\s*)$/.exec(mediaFeatureValueStr)[1],\n        value: mediaFeatureValueStr.trim(),\n      }\n      // +1 for the colon\n      mediaFeatureValue.sourceIndex =\n        mediaFeatureValue.before.length + i + 1 + indexLocal\n      colon = {\n        type: 'colon',\n        sourceIndex: i + indexLocal,\n        after: mediaFeatureValue.before,\n        value: ':', // for consistency only\n      }\n      break\n    }\n\n    mediaFeature += character\n  }\n\n  // Forming a media feature node\n  mediaFeature = {\n    type: 'media-feature',\n    before: /^(\\s*)/.exec(mediaFeature)[1],\n    after: /(\\s*)$/.exec(mediaFeature)[1],\n    value: mediaFeature.trim(),\n  }\n  mediaFeature.sourceIndex = mediaFeature.before.length + indexLocal\n  result.push(mediaFeature)\n\n  if (colon !== null) {\n    colon.before = mediaFeature.after\n    result.push(colon)\n  }\n\n  if (mediaFeatureValue !== null) {\n    result.push(mediaFeatureValue)\n  }\n\n  return result\n}\n\n//\n//---------//\n// Exports //\n//---------//\n\nexport default parseMediaFeature\n","//---------//\n// Imports //\n//---------//\n\nimport Container from '../nodes/container'\nimport Node from '../nodes/node'\nimport parseMediaFeature from './feature'\n\n//\n//------//\n// Main //\n//------//\n\n/**\n * Parses a media query, e.g. `screen and (color)`, `only tv`\n *\n * @param {string} string - the source media query string\n * @param {Number} index - the index of `string` in the overall input\n *\n * @return {Array} an array of Nodes and Containers\n */\n\nfunction parseMediaQuery(string, index = 0) {\n  const result = []\n\n  // How many timies the parser entered parens/curly braces\n  let localLevel = 0\n  // Has any keyword, media type, media feature expression or interpolation\n  // ('element' hereafter) started\n  let insideSomeValue = false\n  let node\n\n  function resetNode() {\n    return {\n      before: '',\n      after: '',\n      value: '',\n    }\n  }\n\n  node = resetNode()\n\n  for (let i = 0; i < string.length; i++) {\n    const character = string[i]\n    // If not yet entered any element\n    if (!insideSomeValue) {\n      if (character.search(/\\s/) !== -1) {\n        // A whitespace\n        // Don't form 'after' yet; will do it later\n        node.before += character\n      } else {\n        // Not a whitespace - entering an element\n        // Expression start\n        if (character === '(') {\n          node.type = 'media-feature-expression'\n          localLevel++\n        }\n        node.value = character\n        node.sourceIndex = index + i\n        insideSomeValue = true\n      }\n    } else {\n      // Already in the middle of some alement\n      node.value += character\n\n      // Here parens just increase localLevel and don't trigger a start of\n      // a media feature expression (since they can't be nested)\n      // Interpolation start\n      if (character === '{' || character === '(') {\n        localLevel++\n      }\n      // Interpolation/function call/media feature expression end\n      if (character === ')' || character === '}') {\n        localLevel--\n      }\n    }\n\n    // If exited all parens/curlies and the next symbol\n    if (\n      insideSomeValue &&\n      localLevel === 0 &&\n      (character === ')' ||\n        i === string.length - 1 ||\n        string[i + 1].search(/\\s/) !== -1)\n    ) {\n      if (['not', 'only', 'and'].indexOf(node.value) !== -1) {\n        node.type = 'keyword'\n      }\n      // if it's an expression, parse its contents\n      if (node.type === 'media-feature-expression') {\n        node.nodes = parseMediaFeature(node.value, node.sourceIndex)\n      }\n      result.push(\n        Array.isArray(node.nodes) ? new Container(node) : new Node(node)\n      )\n      node = resetNode()\n      insideSomeValue = false\n    }\n  }\n\n  // Now process the result array - to specify undefined types of the nodes\n  // and specify the `after` prop\n  for (let i = 0; i < result.length; i++) {\n    node = result[i]\n    if (i > 0) {\n      result[i - 1].after = node.before\n    }\n\n    // Node types. Might not be set because contains interpolation/function\n    // calls or fully consists of them\n    if (node.type === undefined) {\n      if (i > 0) {\n        // only `and` can follow an expression\n        if (result[i - 1].type === 'media-feature-expression') {\n          node.type = 'keyword'\n          continue\n        }\n        // Anything after 'only|not' is a media type\n        if (result[i - 1].value === 'not' || result[i - 1].value === 'only') {\n          node.type = 'media-type'\n          continue\n        }\n        // Anything after 'and' is an expression\n        if (result[i - 1].value === 'and') {\n          node.type = 'media-feature-expression'\n          continue\n        }\n\n        if (result[i - 1].type === 'media-type') {\n          // if it is the last element - it might be an expression\n          // or 'and' depending on what is after it\n          if (!result[i + 1]) {\n            node.type = 'media-feature-expression'\n          } else {\n            node.type =\n              result[i + 1].type === 'media-feature-expression'\n                ? 'keyword'\n                : 'media-feature-expression'\n          }\n        }\n      }\n\n      if (i === 0) {\n        // `screen`, `fn( ... )`, `#{ ... }`. Not an expression, since then\n        // its type would have been set by now\n        if (!result[i + 1]) {\n          node.type = 'media-type'\n          continue\n        }\n\n        // `screen and` or `#{...} (max-width: 10px)`\n        if (\n          result[i + 1] &&\n          (result[i + 1].type === 'media-feature-expression' ||\n            result[i + 1].type === 'keyword')\n        ) {\n          node.type = 'media-type'\n          continue\n        }\n        if (result[i + 2]) {\n          // `screen and (color) ...`\n          if (result[i + 2].type === 'media-feature-expression') {\n            node.type = 'media-type'\n            result[i + 1].type = 'keyword'\n            continue\n          }\n          // `only screen and ...`\n          if (result[i + 2].type === 'keyword') {\n            node.type = 'keyword'\n            result[i + 1].type = 'media-type'\n            continue\n          }\n        }\n        if (result[i + 3]) {\n          // `screen and (color) ...`\n          if (result[i + 3].type === 'media-feature-expression') {\n            node.type = 'keyword'\n            result[i + 1].type = 'media-type'\n            result[i + 2].type = 'keyword'\n            continue\n          }\n        }\n      }\n    }\n  }\n  return result\n}\n\n//\n//---------//\n// Exports //\n//---------//\n\nexport default parseMediaQuery\n","//---------//\n// Imports //\n//---------//\n\nimport Container from '../nodes/container'\nimport Node from '../nodes/node'\nimport parseMediaQuery from './query'\n\n//\n//------//\n// Main //\n//------//\n\n/**\n * Parses a media query list. Takes a possible `url()` at the start into\n * account, and divides the list into media queries that are parsed separately\n *\n * @param {string} string - the source media query list string\n *\n * @return {Array} an array of Nodes/Containers\n */\n\nfunction parseMediaList(string) {\n  const result = []\n  let interimIndex = 0\n  let levelLocal = 0\n\n  // Check for a `url(...)` part (if it is contents of an @import rule)\n  const doesHaveUrl = /^(\\s*)url\\s*\\(/.exec(string)\n  if (doesHaveUrl !== null) {\n    let i = doesHaveUrl[0].length\n    let parenthesesLv = 1\n    while (parenthesesLv > 0) {\n      const character = string[i]\n      if (character === '(') {\n        parenthesesLv++\n      }\n      if (character === ')') {\n        parenthesesLv--\n      }\n      i++\n    }\n    result.unshift(\n      new Node({\n        type: 'url',\n        value: string.substring(0, i).trim(),\n        sourceIndex: doesHaveUrl[1].length,\n        before: doesHaveUrl[1],\n        after: /^(\\s*)/.exec(string.substring(i))[1],\n      })\n    )\n    interimIndex = i\n  }\n\n  // Start processing the media query list\n  for (let i = interimIndex; i < string.length; i++) {\n    const character = string[i]\n\n    // Dividing the media query list into comma-separated media queries\n    // Only count commas that are outside of any parens\n    // (i.e., not part of function call params list, etc.)\n    if (character === '(') {\n      levelLocal++\n    }\n    if (character === ')') {\n      levelLocal--\n    }\n    if (levelLocal === 0 && character === ',') {\n      const mediaQueryString = string.substring(interimIndex, i)\n      const spaceBefore = /^(\\s*)/.exec(mediaQueryString)[1]\n      result.push(\n        new Container({\n          type: 'media-query',\n          value: mediaQueryString.trim(),\n          sourceIndex: interimIndex + spaceBefore.length,\n          nodes: parseMediaQuery(mediaQueryString, interimIndex),\n          before: spaceBefore,\n          after: /(\\s*)$/.exec(mediaQueryString)[1],\n        })\n      )\n      interimIndex = i + 1\n    }\n  }\n\n  const mediaQueryString = string.substring(interimIndex)\n  const spaceBefore = /^(\\s*)/.exec(mediaQueryString)[1]\n  result.push(\n    new Container({\n      type: 'media-query',\n      value: mediaQueryString.trim(),\n      sourceIndex: interimIndex + spaceBefore.length,\n      nodes: parseMediaQuery(mediaQueryString, interimIndex),\n      before: spaceBefore,\n      after: /(\\s*)$/.exec(mediaQueryString)[1],\n    })\n  )\n\n  return result\n}\n\n//\n//---------//\n// Exports //\n//---------//\n\nexport default parseMediaList\n","/**\n * Parses a media query list into an array of nodes. A typical node signature:\n *  {string} node.type -- one of: 'media-query', 'media-type', 'keyword',\n *    'media-feature-expression', 'media-feature', 'colon', 'value'\n *  {string} node.value -- the contents of a particular element, trimmed\n *    e.g.: `screen`, `max-width`, `1024px`\n *  {string} node.after -- whitespaces that follow the element\n *  {string} node.before -- whitespaces that precede the element\n *  {string} node.sourceIndex -- the index of the element in a source media\n *    query list, 0-based\n *  {object} node.parent -- a link to the parent node (a container)\n *\n * Some nodes (media queries, media feature expressions) contain other nodes.\n * They additionally have:\n *  {array} node.nodes -- an array of nodes of the type described here\n *  {funciton} node.each -- traverses direct children of the node, calling\n *    a callback for each one\n *  {funciton} node.walk -- traverses ALL descendants of the node, calling\n *    a callback for each one\n */\n\nimport Container from '../nodes/container'\nimport parseMediaList from './list'\n\nfunction parseMedia(value) {\n  return new Container({\n    nodes: parseMediaList(value),\n    type: 'media-query-list',\n    value: value.trim(),\n  })\n}\n\nexport default parseMedia\n","export { default } from './parse-media'\n"],"sourceRoot":""}