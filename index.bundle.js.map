{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/nodes/node.mjs","webpack:///./src/nodes/container.mjs","webpack:///./src/parse-media/feature.mjs","webpack:///./src/parse-media/query.mjs","webpack:///./src/parse-media/list.mjs","webpack:///./src/parse-media/index.mjs","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","w","s","Node","opts","this","after","before","type","sourceIndex","container","container_Container","[object Object]","super","nodes","undefined","length","forEach","node","parent","filter","cb","hasFilter","RegExp","callback","filterReg","test","walk","container_noop","feature","parseMediaFeature","string","index","modesEntered","mode","character","result","lastModeIndex","mediaFeature","colon","mediaFeatureValue","indexLocal","stringNormalized","substring","isCalculationEnabled","push","pop","mediaFeatureValueStr","exec","trim","query","query_parseMediaQuery","localLevel","insideSomeValue","search","indexOf","Array","isArray","list","list_parseMediaList","interimIndex","levelLocal","doesHaveUrl","parenthesesLv","unshift","mediaQueryString","spaceBefore","__webpack_exports__","parse_media_parseMedia","_parseMedia","_interopRequireDefault"],"mappings":"2BACA,IAAAA,KAMA,SAAAC,oBAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,IACAG,EAAAH,EACAI,GAAA,EACAH,YAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,IAAAD,QAAAF,qBAGAG,EAAAE,GAAA,EAGAF,EAAAD,QA8CA,OAzCAF,oBAAAQ,EAAAF,EAGAN,oBAAAS,EAAAV,EAGAC,oBAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,oBAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAZ,oBAAAmB,EAAA,SAAAjB,GACAY,OAAAC,eAAAb,EAAA,cAAiDkB,OAAA,KAIjDpB,oBAAAqB,EAAA,SAAAlB,GACA,IAAAS,EAAAT,KAAAmB,WACA,SAAAC,aAA2B,OAAApB,EAAA,SAC3B,SAAAqB,mBAAiC,OAAArB,GAEjC,OADAH,oBAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,oBAAAa,EAAA,SAAAY,EAAAC,GAAsD,OAAAZ,OAAAa,UAAAC,eAAArB,KAAAkB,EAAAC,IAGtD1B,oBAAA6B,EAAA,GAGA7B,oBAAA8B,KAIA9B,wCAAA+B,EAAA,kCCrEA,SAAAC,KAAAC,GACAC,KAAAC,MAAAF,EAAAE,MACAD,KAAAE,OAAAH,EAAAG,OACAF,KAAAG,KAAAJ,EAAAI,KACAH,KAAAd,MAAAa,EAAAb,MACAc,KAAAI,YAAAL,EAAAK,mBC4FA,IAAAC,QAvFAC,4BAAAR,KACAS,YAAAR,GACAS,MAAAT,GAEAC,KAAAS,MAAAV,EAAAU,WAEAC,IAAAV,KAAAC,QACAD,KAAAC,MACAD,KAAAS,MAAAE,OAAA,EAAAX,KAAAS,MAAAT,KAAAS,MAAAE,OAAA,GAAAV,MAAA,SAGAS,IAAAV,KAAAE,SACAF,KAAAE,OAAAF,KAAAS,MAAAE,OAAA,EAAAX,KAAAS,MAAA,GAAAP,OAAA,SAGAQ,IAAAV,KAAAI,cACAJ,KAAAI,YAAAJ,KAAAE,OAAAS,QAGAX,KAAAS,MAAAG,QAAAC,IACAA,EAAAC,OAAAd,OAgBAO,KAAAQ,EAAAC,GACA,MAAAC,EAAA,iBAAAF,gBAAAG,OACAC,EAAAF,EAAAD,EAAAD,EACAK,EAAA,iBAAAL,EAAA,IAAAG,OAAAH,KAEA,QAAA7C,EAAA,EAAmBA,EAAA8B,KAAAS,MAAAE,OAAuBzC,IAAA,CAC1C,MAAA2C,EAAAb,KAAAS,MAAAvC,GAEA,KADA+C,GAAAG,EAAAC,KAAAR,EAAAV,QACAgB,IAAA,IAAAA,EAAAN,EAAA3C,EAAA8B,KAAAS,OACA,SAEA,GAAAI,EAAAJ,QAAA,IAAAI,EAAAS,KAAAP,EAAAC,GACA,SAGA,SAaAT,KAAAS,EAgBA,SAAAO,oBAfA,QAAArD,EAAA,EAAmBA,EAAA8B,KAAAS,MAAAE,OAAuBzC,IAE1C,QAAA8C,EADAhB,KAAAS,MAAAvC,GACAA,EAAA8B,KAAAS,OACA,SAGA,WCoCA,IAAAe,EA3GA,SAAAC,kBAAAC,EAAAC,EAAA,GACA,MAAAC,IAEAC,KAAA,SACAC,UAAA,OAGAC,KACA,IAAAC,EAAA,EACAC,EAAA,GACAC,EAAA,KACAC,EAAA,KACAC,EAAAT,EAEAU,EAAAX,EAEA,MAAAA,EAAA,UAAAA,IAAAf,OAAA,KACA0B,EAAAX,EAAAY,UAAA,EAAAZ,EAAAf,OAAA,GACAyB,KAGA,QAAAlE,EAAA,EAAiBA,EAAAmE,EAAA1B,OAA6BzC,IAAA,CAC9C,MAAA4D,EAAAO,EAAAnE,GAmCA,GAhCA,MAAA4D,GAAA,MAAAA,KACA,IAAAF,EAAAI,GAAAO,sBACAX,EAAAY,MACAX,KAAA,SACAU,sBAAA,EACAT,cAEAE,KAEA,WAAAJ,EAAAI,GAAAH,MACAD,EAAAI,GAAAF,eACA,OAAAO,EAAAnE,EAAA,KAEA0D,EAAAa,MACAT,MAKA,MAAAF,GACAF,EAAAY,MACAX,KAAA,gBACAU,sBAAA,IAEAP,KACK,MAAAF,IACLF,EAAAa,MACAT,KAKA,WAAAJ,EAAAI,GAAAH,MAAA,MAAAC,EAAA,CACA,MAAAY,EAAAL,EAAAC,UAAApE,EAAA,IACAiE,GACAhC,KAAA,QACAD,OAAA,SAAAyC,KAAAD,GAAA,GACAzC,MAAA,SAAA0C,KAAAD,GAAA,GACAxD,MAAAwD,EAAAE,SAGAxC,YACA+B,EAAAjC,OAAAS,OAAAzC,EAAA,EAAAkE,EACAF,GACA/B,KAAA,QACAC,YAAAlC,EAAAkE,EACAnC,MAAAkC,EAAAjC,OACAhB,MAAA,KAEA,MAGA+C,GAAAH,EAsBA,OAlBAG,GACA9B,KAAA,gBACAD,OAAA,SAAAyC,KAAAV,GAAA,GACAhC,MAAA,SAAA0C,KAAAV,GAAA,GACA/C,MAAA+C,EAAAW,SAEAxC,YAAA6B,EAAA/B,OAAAS,OAAAyB,EACAL,EAAAS,KAAAP,GAEA,OAAAC,IACAA,EAAAhC,OAAA+B,EAAAhC,MACA8B,EAAAS,KAAAN,IAGA,OAAAC,GACAJ,EAAAS,KAAAL,GAGAJ,GCgFA,IAAAc,EA3KA,SAAAC,sBAAApB,EAAAC,EAAA,GACA,MAAAI,KAGA,IAIAlB,EAJAkC,EAAA,EAGAC,GAAA,EAWAnC,GANAX,OAAA,GACAD,MAAA,GACAf,MAAA,IAMA,QAAAhB,EAAA,EAAiBA,EAAAwD,EAAAf,OAAmBzC,IAAA,CACpC,MAAA4D,EAAAJ,EAAAxD,GAEA8E,GAkBAnC,EAAA3B,OAAA4C,EAKA,MAAAA,GAA0B,MAAAA,GAC1BiB,IAGA,MAAAjB,GAAA,MAAAA,GACAiB,MA3BA,IAAAjB,EAAAmB,OAAA,MAGApC,EAAAX,QAAA4B,GAIA,MAAAA,IACAjB,EAAAV,KAAA,2BACA4C,KAEAlC,EAAA3B,MAAA4C,EACAjB,EAAAT,YAAAuB,EAAAzD,EACA8E,GAAA,IAoBAA,GACA,IAAAD,GACA,MAAAjB,GACA5D,IAAAwD,EAAAf,OAAA,IACA,IAAAe,EAAAxD,EAAA,GAAA+E,OAAA,SAEA,yBAAAC,QAAArC,EAAA3B,SACA2B,EAAAV,KAAA,WAGA,6BAAAU,EAAAV,OACAU,EAAAJ,MAAAe,EAAAX,EAAA3B,MAAA2B,EAAAT,cAEA2B,EAAAS,KACAW,MAAAC,QAAAvC,EAAAJ,OAAA,IAAAJ,EAAAQ,GAAA,IAAAf,KAAAe,IAEAA,GA7DAX,OAAA,GACAD,MAAA,GACAf,MAAA,IA4DA8D,GAAA,GAMA,QAAA9E,EAAA,EAAiBA,EAAA6D,EAAApB,OAAmBzC,IAQpC,GAPA2C,EAAAkB,EAAA7D,GACAA,EAAA,IACA6D,EAAA7D,EAAA,GAAA+B,MAAAY,EAAAX,aAKAQ,IAAAG,EAAAV,KAAA,CACA,GAAAjC,EAAA,GAEA,gCAAA6D,EAAA7D,EAAA,GAAAiC,KAAA,CACAU,EAAAV,KAAA,UACA,SAGA,WAAA4B,EAAA7D,EAAA,GAAAgB,OAAA,SAAA6C,EAAA7D,EAAA,GAAAgB,MAAA,CACA2B,EAAAV,KAAA,aACA,SAGA,WAAA4B,EAAA7D,EAAA,GAAAgB,MAAA,CACA2B,EAAAV,KAAA,2BACA,SAGA,eAAA4B,EAAA7D,EAAA,GAAAiC,OAGA4B,EAAA7D,EAAA,GAGA2C,EAAAV,KACA,6BAAA4B,EAAA7D,EAAA,GAAAiC,KACA,UACA,2BALAU,EAAAV,KAAA,4BAUA,OAAAjC,EAAA,CAGA,IAAA6D,EAAA7D,EAAA,IACA2C,EAAAV,KAAA,aACA,SAIA,GACA4B,EAAA7D,EAAA,KACA,6BAAA6D,EAAA7D,EAAA,GAAAiC,MACA,YAAA4B,EAAA7D,EAAA,GAAAiC,MACA,CACAU,EAAAV,KAAA,aACA,SAEA,GAAA4B,EAAA7D,EAAA,IAEA,gCAAA6D,EAAA7D,EAAA,GAAAiC,KAAA,CACAU,EAAAV,KAAA,aACA4B,EAAA7D,EAAA,GAAAiC,KAAA,UACA,SAGA,eAAA4B,EAAA7D,EAAA,GAAAiC,KAAA,CACAU,EAAAV,KAAA,UACA4B,EAAA7D,EAAA,GAAAiC,KAAA,aACA,UAGA,GAAA4B,EAAA7D,EAAA,IAEA,6BAAA6D,EAAA7D,EAAA,GAAAiC,KAAA,CACAU,EAAAV,KAAA,UACA4B,EAAA7D,EAAA,GAAAiC,KAAA,aACA4B,EAAA7D,EAAA,GAAAiC,KAAA,UACA,WAMA,OAAA4B,GChFA,IAAAsB,EAnFA,SAAAC,oBAAA5B,GACA,MAAAK,KACA,IAAAwB,EAAA,EACAC,EAAA,EAGA,MAAAC,EAAA,iBAAAd,KAAAjB,GACA,UAAA+B,EAAA,CACA,IAAAvF,EAAAuF,EAAA,GAAA9C,OACA+C,EAAA,EACA,KAAAA,EAAA,IACA,MAAA5B,EAAAJ,EAAAxD,GACA,MAAA4D,GACA4B,IAEA,MAAA5B,GACA4B,IAEAxF,IAEA6D,EAAA4B,QACA,IAAA7D,MACAK,KAAA,MACAjB,MAAAwC,EAAAY,UAAA,EAAApE,GAAA0E,OACAxC,YAAAqD,EAAA,GAAA9C,OACAT,OAAAuD,EAAA,GACAxD,MAAA,SAAA0C,KAAAjB,EAAAY,UAAApE,IAAA,MAGAqF,EAAArF,EAIA,QAAAA,EAAAqF,EAA4BrF,EAAAwD,EAAAf,OAAmBzC,IAAA,CAC/C,MAAA4D,EAAAJ,EAAAxD,GAWA,GANA,MAAA4D,GACA0B,IAEA,MAAA1B,GACA0B,IAEA,IAAAA,GAAA,MAAA1B,EAAA,CACA,MAAA8B,EAAAlC,EAAAY,UAAAiB,EAAArF,GACA2F,EAAA,SAAAlB,KAAAiB,GAAA,GACA7B,EAAAS,KACA,IAAAnC,GACAF,KAAA,cACAjB,MAAA0E,EAAAhB,OACAxC,YAAAmD,EAAAM,EAAAlD,OACAF,MAAAoC,EAAAe,EAAAL,GACArD,OAAA2D,EACA5D,MAAA,SAAA0C,KAAAiB,GAAA,MAGAL,EAAArF,EAAA,GAIA,MAAA0F,EAAAlC,EAAAY,UAAAiB,GACAM,EAAA,SAAAlB,KAAAiB,GAAA,GAYA,OAXA7B,EAAAS,KACA,IAAAnC,GACAF,KAAA,cACAjB,MAAA0E,EAAAhB,OACAxC,YAAAmD,EAAAM,EAAAlD,OACAF,MAAAoC,EAAAe,EAAAL,GACArD,OAAA2D,EACA5D,MAAA,SAAA0C,KAAAiB,GAAA,MAIA7B,GCjEA+B,EAAA,QARA,SAAAC,uBAAA7E,GACA,WAAAmB,GACAI,MAAA4C,EAAAnE,GACAiB,KAAA,mBACAjB,QAAA0D,iLC5BA,IAAAoB,0EAAAC,CAAAnG,EAAA","file":"index.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading wasm modules\n \tvar installedWasmModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// object with all compiled WebAssembly.Modules\n \t__webpack_require__.w = {};\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/**\n * A very generic node. Pretty much any element of a media query\n */\n\nexport default function Node(opts) {\n  this.after = opts.after\n  this.before = opts.before\n  this.type = opts.type\n  this.value = opts.value\n  this.sourceIndex = opts.sourceIndex\n}\n","//---------//\n// Imports //\n//---------//\n\nimport Node from './node'\n\n//\n//------//\n// Main //\n//------//\n\n/**\n * A node that contains other nodes and support traversing over them\n */\nclass Container extends Node {\n  constructor(opts) {\n    super(opts)\n\n    this.nodes = opts.nodes\n\n    if (this.after === undefined) {\n      this.after =\n        this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ''\n    }\n\n    if (this.before === undefined) {\n      this.before = this.nodes.length > 0 ? this.nodes[0].before : ''\n    }\n\n    if (this.sourceIndex === undefined) {\n      this.sourceIndex = this.before.length\n    }\n\n    this.nodes.forEach(node => {\n      node.parent = this // eslint-disable-line no-param-reassign\n    })\n  }\n\n  /**\n   * Iterate over descendant nodes of the node\n   *\n   * @param {RegExp|string} filter - Optional. Only nodes with node.type that\n   *    satisfies the filter will be traversed over\n   * @param {function} cb - callback to call on each node. Takes theese params:\n   *    node - the node being processed, i - it's index, nodes - the array\n   *    of all nodes\n   *    If false is returned, the iteration breaks\n   *\n   * @return (boolean) false, if the iteration was broken\n   */\n  walk(filter, cb) {\n    const hasFilter = typeof filter === 'string' || filter instanceof RegExp\n    const callback = hasFilter ? cb : filter\n    const filterReg = typeof filter === 'string' ? new RegExp(filter) : filter\n\n    for (let i = 0; i < this.nodes.length; i++) {\n      const node = this.nodes[i]\n      const filtered = hasFilter ? filterReg.test(node.type) : true\n      if (filtered && callback && callback(node, i, this.nodes) === false) {\n        return false\n      }\n      if (node.nodes && node.walk(filter, cb) === false) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * Iterate over immediate children of the node\n   *\n   * @param {function} cb - callback to call on each node. Takes theese params:\n   *    node - the node being processed, i - it's index, nodes - the array\n   *    of all nodes\n   *    If false is returned, the iteration breaks\n   *\n   * @return (boolean) false, if the iteration was broken\n   */\n  each(cb = noop) {\n    for (let i = 0; i < this.nodes.length; i++) {\n      const node = this.nodes[i]\n      if (cb(node, i, this.nodes) === false) {\n        return false\n      }\n    }\n    return true\n  }\n}\n\n//\n//------------------//\n// Helper Functions //\n//------------------//\n\nfunction noop() {}\n\n//\n//---------//\n// Exports //\n//---------//\n\nexport default Container\n","//------//\n// Main //\n//------//\n\n/**\n * Parses a media feature expression, e.g. `max-width: 10px`, `(color)`\n *\n * @param {string} string - the source expression string, can be inside parens\n * @param {Number} index - the index of `string` in the overall input\n *\n * @return {Array} an array of Nodes, the first element being a media feature,\n *    the secont - its value (may be missing)\n */\n\nfunction parseMediaFeature(string, index = 0) {\n  const modesEntered = [\n    {\n      mode: 'normal',\n      character: null,\n    },\n  ]\n  const result = []\n  let lastModeIndex = 0\n  let mediaFeature = ''\n  let colon = null\n  let mediaFeatureValue = null\n  let indexLocal = index\n\n  let stringNormalized = string\n  // Strip trailing parens (if any), and correct the starting index\n  if (string[0] === '(' && string[string.length - 1] === ')') {\n    stringNormalized = string.substring(1, string.length - 1)\n    indexLocal++\n  }\n\n  for (let i = 0; i < stringNormalized.length; i++) {\n    const character = stringNormalized[i]\n\n    // If entering/exiting a string\n    if (character === \"'\" || character === '\"') {\n      if (modesEntered[lastModeIndex].isCalculationEnabled === true) {\n        modesEntered.push({\n          mode: 'string',\n          isCalculationEnabled: false,\n          character,\n        })\n        lastModeIndex++\n      } else if (\n        modesEntered[lastModeIndex].mode === 'string' &&\n        modesEntered[lastModeIndex].character === character &&\n        stringNormalized[i - 1] !== '\\\\'\n      ) {\n        modesEntered.pop()\n        lastModeIndex--\n      }\n    }\n\n    // If entering/exiting interpolation\n    if (character === '{') {\n      modesEntered.push({\n        mode: 'interpolation',\n        isCalculationEnabled: true,\n      })\n      lastModeIndex++\n    } else if (character === '}') {\n      modesEntered.pop()\n      lastModeIndex--\n    }\n\n    // If a : is met outside of a string, function call or interpolation, than\n    // this : separates a media feature and a value\n    if (modesEntered[lastModeIndex].mode === 'normal' && character === ':') {\n      const mediaFeatureValueStr = stringNormalized.substring(i + 1)\n      mediaFeatureValue = {\n        type: 'value',\n        before: /^(\\s*)/.exec(mediaFeatureValueStr)[1],\n        after: /(\\s*)$/.exec(mediaFeatureValueStr)[1],\n        value: mediaFeatureValueStr.trim(),\n      }\n      // +1 for the colon\n      mediaFeatureValue.sourceIndex =\n        mediaFeatureValue.before.length + i + 1 + indexLocal\n      colon = {\n        type: 'colon',\n        sourceIndex: i + indexLocal,\n        after: mediaFeatureValue.before,\n        value: ':', // for consistency only\n      }\n      break\n    }\n\n    mediaFeature += character\n  }\n\n  // Forming a media feature node\n  mediaFeature = {\n    type: 'media-feature',\n    before: /^(\\s*)/.exec(mediaFeature)[1],\n    after: /(\\s*)$/.exec(mediaFeature)[1],\n    value: mediaFeature.trim(),\n  }\n  mediaFeature.sourceIndex = mediaFeature.before.length + indexLocal\n  result.push(mediaFeature)\n\n  if (colon !== null) {\n    colon.before = mediaFeature.after\n    result.push(colon)\n  }\n\n  if (mediaFeatureValue !== null) {\n    result.push(mediaFeatureValue)\n  }\n\n  return result\n}\n\n//\n//---------//\n// Exports //\n//---------//\n\nexport default parseMediaFeature\n","//---------//\n// Imports //\n//---------//\n\nimport Container from '../nodes/container'\nimport Node from '../nodes/node'\nimport parseMediaFeature from './feature'\n\n//\n//------//\n// Main //\n//------//\n\n/**\n * Parses a media query, e.g. `screen and (color)`, `only tv`\n *\n * @param {string} string - the source media query string\n * @param {Number} index - the index of `string` in the overall input\n *\n * @return {Array} an array of Nodes and Containers\n */\n\nfunction parseMediaQuery(string, index = 0) {\n  const result = []\n\n  // How many timies the parser entered parens/curly braces\n  let localLevel = 0\n  // Has any keyword, media type, media feature expression or interpolation\n  // ('element' hereafter) started\n  let insideSomeValue = false\n  let node\n\n  function resetNode() {\n    return {\n      before: '',\n      after: '',\n      value: '',\n    }\n  }\n\n  node = resetNode()\n\n  for (let i = 0; i < string.length; i++) {\n    const character = string[i]\n    // If not yet entered any element\n    if (!insideSomeValue) {\n      if (character.search(/\\s/) !== -1) {\n        // A whitespace\n        // Don't form 'after' yet; will do it later\n        node.before += character\n      } else {\n        // Not a whitespace - entering an element\n        // Expression start\n        if (character === '(') {\n          node.type = 'media-feature-expression'\n          localLevel++\n        }\n        node.value = character\n        node.sourceIndex = index + i\n        insideSomeValue = true\n      }\n    } else {\n      // Already in the middle of some alement\n      node.value += character\n\n      // Here parens just increase localLevel and don't trigger a start of\n      // a media feature expression (since they can't be nested)\n      // Interpolation start\n      if (character === '{' || character === '(') {\n        localLevel++\n      }\n      // Interpolation/function call/media feature expression end\n      if (character === ')' || character === '}') {\n        localLevel--\n      }\n    }\n\n    // If exited all parens/curlies and the next symbol\n    if (\n      insideSomeValue &&\n      localLevel === 0 &&\n      (character === ')' ||\n        i === string.length - 1 ||\n        string[i + 1].search(/\\s/) !== -1)\n    ) {\n      if (['not', 'only', 'and'].indexOf(node.value) !== -1) {\n        node.type = 'keyword'\n      }\n      // if it's an expression, parse its contents\n      if (node.type === 'media-feature-expression') {\n        node.nodes = parseMediaFeature(node.value, node.sourceIndex)\n      }\n      result.push(\n        Array.isArray(node.nodes) ? new Container(node) : new Node(node)\n      )\n      node = resetNode()\n      insideSomeValue = false\n    }\n  }\n\n  // Now process the result array - to specify undefined types of the nodes\n  // and specify the `after` prop\n  for (let i = 0; i < result.length; i++) {\n    node = result[i]\n    if (i > 0) {\n      result[i - 1].after = node.before\n    }\n\n    // Node types. Might not be set because contains interpolation/function\n    // calls or fully consists of them\n    if (node.type === undefined) {\n      if (i > 0) {\n        // only `and` can follow an expression\n        if (result[i - 1].type === 'media-feature-expression') {\n          node.type = 'keyword'\n          continue\n        }\n        // Anything after 'only|not' is a media type\n        if (result[i - 1].value === 'not' || result[i - 1].value === 'only') {\n          node.type = 'media-type'\n          continue\n        }\n        // Anything after 'and' is an expression\n        if (result[i - 1].value === 'and') {\n          node.type = 'media-feature-expression'\n          continue\n        }\n\n        if (result[i - 1].type === 'media-type') {\n          // if it is the last element - it might be an expression\n          // or 'and' depending on what is after it\n          if (!result[i + 1]) {\n            node.type = 'media-feature-expression'\n          } else {\n            node.type =\n              result[i + 1].type === 'media-feature-expression'\n                ? 'keyword'\n                : 'media-feature-expression'\n          }\n        }\n      }\n\n      if (i === 0) {\n        // `screen`, `fn( ... )`, `#{ ... }`. Not an expression, since then\n        // its type would have been set by now\n        if (!result[i + 1]) {\n          node.type = 'media-type'\n          continue\n        }\n\n        // `screen and` or `#{...} (max-width: 10px)`\n        if (\n          result[i + 1] &&\n          (result[i + 1].type === 'media-feature-expression' ||\n            result[i + 1].type === 'keyword')\n        ) {\n          node.type = 'media-type'\n          continue\n        }\n        if (result[i + 2]) {\n          // `screen and (color) ...`\n          if (result[i + 2].type === 'media-feature-expression') {\n            node.type = 'media-type'\n            result[i + 1].type = 'keyword'\n            continue\n          }\n          // `only screen and ...`\n          if (result[i + 2].type === 'keyword') {\n            node.type = 'keyword'\n            result[i + 1].type = 'media-type'\n            continue\n          }\n        }\n        if (result[i + 3]) {\n          // `screen and (color) ...`\n          if (result[i + 3].type === 'media-feature-expression') {\n            node.type = 'keyword'\n            result[i + 1].type = 'media-type'\n            result[i + 2].type = 'keyword'\n            continue\n          }\n        }\n      }\n    }\n  }\n  return result\n}\n\n//\n//---------//\n// Exports //\n//---------//\n\nexport default parseMediaQuery\n","//---------//\n// Imports //\n//---------//\n\nimport Container from '../nodes/container'\nimport Node from '../nodes/node'\nimport parseMediaQuery from './query'\n\n//\n//------//\n// Main //\n//------//\n\n/**\n * Parses a media query list. Takes a possible `url()` at the start into\n * account, and divides the list into media queries that are parsed separately\n *\n * @param {string} string - the source media query list string\n *\n * @return {Array} an array of Nodes/Containers\n */\n\nfunction parseMediaList(string) {\n  const result = []\n  let interimIndex = 0\n  let levelLocal = 0\n\n  // Check for a `url(...)` part (if it is contents of an @import rule)\n  const doesHaveUrl = /^(\\s*)url\\s*\\(/.exec(string)\n  if (doesHaveUrl !== null) {\n    let i = doesHaveUrl[0].length\n    let parenthesesLv = 1\n    while (parenthesesLv > 0) {\n      const character = string[i]\n      if (character === '(') {\n        parenthesesLv++\n      }\n      if (character === ')') {\n        parenthesesLv--\n      }\n      i++\n    }\n    result.unshift(\n      new Node({\n        type: 'url',\n        value: string.substring(0, i).trim(),\n        sourceIndex: doesHaveUrl[1].length,\n        before: doesHaveUrl[1],\n        after: /^(\\s*)/.exec(string.substring(i))[1],\n      })\n    )\n    interimIndex = i\n  }\n\n  // Start processing the media query list\n  for (let i = interimIndex; i < string.length; i++) {\n    const character = string[i]\n\n    // Dividing the media query list into comma-separated media queries\n    // Only count commas that are outside of any parens\n    // (i.e., not part of function call params list, etc.)\n    if (character === '(') {\n      levelLocal++\n    }\n    if (character === ')') {\n      levelLocal--\n    }\n    if (levelLocal === 0 && character === ',') {\n      const mediaQueryString = string.substring(interimIndex, i)\n      const spaceBefore = /^(\\s*)/.exec(mediaQueryString)[1]\n      result.push(\n        new Container({\n          type: 'media-query',\n          value: mediaQueryString.trim(),\n          sourceIndex: interimIndex + spaceBefore.length,\n          nodes: parseMediaQuery(mediaQueryString, interimIndex),\n          before: spaceBefore,\n          after: /(\\s*)$/.exec(mediaQueryString)[1],\n        })\n      )\n      interimIndex = i + 1\n    }\n  }\n\n  const mediaQueryString = string.substring(interimIndex)\n  const spaceBefore = /^(\\s*)/.exec(mediaQueryString)[1]\n  result.push(\n    new Container({\n      type: 'media-query',\n      value: mediaQueryString.trim(),\n      sourceIndex: interimIndex + spaceBefore.length,\n      nodes: parseMediaQuery(mediaQueryString, interimIndex),\n      before: spaceBefore,\n      after: /(\\s*)$/.exec(mediaQueryString)[1],\n    })\n  )\n\n  return result\n}\n\n//\n//---------//\n// Exports //\n//---------//\n\nexport default parseMediaList\n","/**\n * Parses a media query list into an array of nodes. A typical node signature:\n *  {string} node.type -- one of: 'media-query', 'media-type', 'keyword',\n *    'media-feature-expression', 'media-feature', 'colon', 'value'\n *  {string} node.value -- the contents of a particular element, trimmed\n *    e.g.: `screen`, `max-width`, `1024px`\n *  {string} node.after -- whitespaces that follow the element\n *  {string} node.before -- whitespaces that precede the element\n *  {string} node.sourceIndex -- the index of the element in a source media\n *    query list, 0-based\n *  {object} node.parent -- a link to the parent node (a container)\n *\n * Some nodes (media queries, media feature expressions) contain other nodes.\n * They additionally have:\n *  {array} node.nodes -- an array of nodes of the type described here\n *  {funciton} node.each -- traverses direct children of the node, calling\n *    a callback for each one\n *  {funciton} node.walk -- traverses ALL descendants of the node, calling\n *    a callback for each one\n */\n\nimport Container from '../nodes/container'\nimport parseMediaList from './list'\n\nfunction parseMedia(value) {\n  return new Container({\n    nodes: parseMediaList(value),\n    type: 'media-query-list',\n    value: value.trim(),\n  })\n}\n\nexport default parseMedia\n","export { default } from './parse-media'\n"],"sourceRoot":""}